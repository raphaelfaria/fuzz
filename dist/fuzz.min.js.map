{"version":3,"sources":["fuzz.min.js","/source/fuzz.js","/source/src/item.js","/source/src/result.js","/source/src/fuzz.js","/source/src/cache.js","/source/src/result-item.js"],"names":["_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","_get","_x","_x2","_x3","_again","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","getter","get","call","parent","getPrototypeOf","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","global","factory","exports","module","define","amd","Fuzz","this","isUpper","char","toUpperCase","nonWordChar","test","indexIsSectionStart","string","index","calculateWeight","name","substringSize","matchIndex","lastMatchIndex","isSectionStart","weight","countSections","count","l","sortByWeight","a","b","isArray","item","Array","toString","Cache","arr","query","indexOf","Item","mainIndex","matchIndexArr","searchIndex","lookUpper","lowerTestName","toLowerCase","currentChar","charAt","j","push","sectionCount","Math","round","Result","_Array","items","meta","sort","apply","map","resultItem","ResultItem","_Array2","collection","options","Error","main","_prepareCollection","assign","disableCache","cache","_this","parse","replace","cached","check","searchArray","clean","resultArray","reduce","searchItem","calcMatch","queryRegex","RegExp","split","join","filter","match","fuzz"],"mappings":"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","file":"fuzz.min.js","sourcesContent":["var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.Fuzz = factory();\n})(this, function () {\n  'use strict';\n\n  var Cache = (function () {\n    function Cache() {\n      _classCallCheck(this, Cache);\n    }\n\n    _createClass(Cache, [{\n      key: 'construct',\n      value: function construct() {\n        this.arr = null;\n        this.query = null;\n      }\n    }, {\n      key: 'clean',\n      value: function clean() {\n        this.arr = null;\n        this.query = null;\n      }\n    }, {\n      key: 'check',\n      value: function check(query) {\n        if (!this.query || !query) {\n          return false;\n        }\n\n        if (query.length < this.query.length) {\n          return false;\n        }\n\n        if (query === this.query) {\n          return true;\n        }\n\n        if (query.indexOf(this.query) === 0) {\n          return true;\n        }\n\n        return false;\n      }\n    }]);\n\n    return Cache;\n  })();\n\n  function isUpper(char) {\n    return char.toUpperCase() === char;\n  }\n\n  function nonWordChar(char) {\n    return (/\\W/.test(char)\n    );\n  }\n\n  function indexIsSectionStart(string, index) {\n    return index === 0 || index === 1 && isUpper(string[index]) || isUpper(string[index]) || nonWordChar(string[index - 1]);\n  }\n\n  function calculateWeight(name, substringSize, matchIndex, lastMatchIndex) {\n    var isSectionStart = indexIsSectionStart(name, matchIndex);\n\n    var weight = 0;\n\n    if (isSectionStart) {\n      weight += 85;\n    }\n\n    if (substringSize > 1) {\n      weight += 50 + 14 * (substringSize - 1);\n    }\n\n    if (lastMatchIndex >= 0 && matchIndex - lastMatchIndex > 0) {\n      weight -= matchIndex - lastMatchIndex;\n    }\n\n    return weight;\n  }\n\n  function countSections(name) {\n    var count = 0;\n\n    var l = name.length;\n\n    for (var i = 0; i < l; i++) {\n      if (indexIsSectionStart(name, i)) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  var Item = (function () {\n    function Item(name, index) {\n      _classCallCheck(this, Item);\n\n      this.name = name;\n      this.mainIndex = index;\n    }\n\n    _createClass(Item, [{\n      key: 'calcMatch',\n      value: function calcMatch(string) {\n        var matchIndexArr = [];\n        var searchIndex = -1;\n        var lookUpper = true;\n        var weight = 0;\n        var substringSize = 1;\n\n        var l = string.length;\n        var lowerTestName = this.name.toLowerCase();\n\n        for (var i = 0; i < l; i++) {\n          var currentChar = string.charAt(i);\n\n          if (searchIndex >= this.name.length) return false;\n\n          if (lookUpper) {\n            for (var j = searchIndex + 1; j < this.name.length; j++) {\n              if (currentChar === this.name[j].toLowerCase() && indexIsSectionStart(this.name, j)) {\n                searchIndex = j;\n                break;\n              }\n\n              searchIndex = -1;\n            }\n          } else {\n            searchIndex = lowerTestName.indexOf(currentChar, searchIndex + 1);\n          }\n\n          if (searchIndex > -1) {\n            if (matchIndexArr[matchIndexArr.length - 1] === searchIndex - 1) {\n              substringSize++;\n            } else {\n              substringSize = 1;\n            }\n\n            matchIndexArr.push(searchIndex);\n            weight += calculateWeight(this.name, substringSize, searchIndex, matchIndexArr[matchIndexArr.length - 2]);\n\n            continue;\n          }\n\n          if (!lookUpper) {\n            matchIndexArr = [];\n            break;\n          }\n\n          i -= 1;\n          searchIndex = matchIndexArr[matchIndexArr.length - 1] || -1;\n          lookUpper = !lookUpper;\n        }\n\n        if (!matchIndexArr.length) {\n          return false;\n        }\n\n        var sectionCount = countSections(this.name);\n\n        weight = weight - Math.round(matchIndexArr[0] * 1.2) - sectionCount * l;\n\n        return weight > 0 ? weight : 0;\n      }\n    }]);\n\n    return Item;\n  })();\n\n  function sortByWeight(a, b) {\n    return b.weight - a.weight;\n  }\n\n  var Result = (function (_Array) {\n    _inherits(Result, _Array);\n\n    function Result(items) {\n      _classCallCheck(this, Result);\n\n      _get(Object.getPrototypeOf(Result.prototype), 'constructor', this).call(this);\n\n      if (!items.length) {\n        return false;\n      }\n\n      this.meta = items.sort(sortByWeight);\n      _get(Object.getPrototypeOf(Result.prototype), 'push', this).apply(this, this.meta.map(function (resultItem) {\n        return resultItem.item.name;\n      }));\n    }\n\n    return Result;\n  })(Array);\n\n  var ResultItem = function ResultItem(item, weight) {\n    _classCallCheck(this, ResultItem);\n\n    this.item = item;\n    this.weight = weight;\n  };\n\n  function isArray(item) {\n    if (Array.isArray) return Array.isArray(item);\n    return (/array/i.test(Object.prototype.toString.call(item))\n    );\n  }\n\n  var Fuzz = (function (_Array2) {\n    _inherits(Fuzz, _Array2);\n\n    function Fuzz(collection, options) {\n      _classCallCheck(this, Fuzz);\n\n      _get(Object.getPrototypeOf(Fuzz.prototype), 'constructor', this).call(this);\n\n      if (!isArray(collection)) {\n        throw new Error('Argument to Fuzz should be an array');\n      }\n\n      this.push.apply(this, collection);\n      this.main = this._prepareCollection();\n      this.options = Object.assign({\n        disableCache: false\n      }, options);\n      this.cache = new Cache();\n    }\n\n    _createClass(Fuzz, [{\n      key: 'parse',\n      value: function parse(item) {\n        return item;\n      }\n    }, {\n      key: '_prepareCollection',\n      value: function _prepareCollection() {\n        var _this = this;\n\n        return this.map(function (item, i) {\n          if (typeof item !== 'string') {\n            throw new Error('Argument to Fuzz should be an array of strings');\n          }\n\n          return new Item(_this.parse(item), i);\n        });\n      }\n    }, {\n      key: 'match',\n      value: function match(string) {\n        var query = string.replace(/\\s+/g, '').toLowerCase();\n        var cached = !this.options.disableCache && this.cache.check(query);\n\n        var searchArray = this.main;\n\n        if (cached) {\n          searchArray = this.cache.arr;\n        } else {\n          this.cache.clean();\n        }\n\n        var resultArray = searchArray.reduce(function (arr, item) {\n          var searchItem = cached ? item.item : item;\n\n          var weight = searchItem.calcMatch(query);\n\n          if (weight !== false) {\n            arr.push(new ResultItem(searchItem, weight));\n          }\n\n          return arr;\n        }, []);\n\n        this.cache.arr = resultArray;\n        this.cache.query = query;\n\n        return new Result(resultArray);\n      }\n    }, {\n      key: 'simpleMatch',\n      value: function simpleMatch(string) {\n        var queryRegex = new RegExp(string.split('').join('.*?'), 'i');\n        return this.filter(function (item) {\n          return queryRegex.test(item);\n        });\n      }\n    }], [{\n      key: 'match',\n      value: function match(string, collection) {\n        return new Fuzz(collection).match(string);\n      }\n    }]);\n\n    return Fuzz;\n  })(Array);\n\n  var fuzz = Fuzz;\n\n  return fuzz;\n});\n//# sourceMappingURL=fuzz.js.map\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Fuzz = factory()\n}(this, function () { 'use strict';\n\n  class Cache {\n    construct() {\n      this.arr = null;\n      this.query = null;\n    }\n\n    clean() {\n      this.arr = null;\n      this.query = null;\n    }\n\n    check(query) {\n      if (!this.query || !query) {\n        return false;\n      }\n\n      if (query.length < this.query.length) {\n        return false;\n      }\n\n      if (query === this.query) {\n        return true;\n      }\n\n      if (query.indexOf(this.query) === 0) {\n        return true;\n      }\n\n      return false;\n    }\n  }\n\n  function isUpper(char) {\n    return char.toUpperCase() === char;\n  }\n\n  function nonWordChar(char) {\n    return /\\W/.test(char);\n  }\n\n  function indexIsSectionStart(string, index) {\n    return index === 0 ||\n      (index === 1 && isUpper(string[index])) ||\n      isUpper(string[index]) || nonWordChar(string[index - 1]);\n  }\n\n  function calculateWeight(name, substringSize, matchIndex, lastMatchIndex) {\n    const isSectionStart = indexIsSectionStart(name, matchIndex);\n\n    let weight = 0;\n\n    if (isSectionStart) {\n      weight += 85;\n    }\n\n    if (substringSize > 1) {\n      weight += (50 + (14 * (substringSize - 1)));\n    }\n\n    if (lastMatchIndex >= 0 && matchIndex - lastMatchIndex > 0) {\n      weight -= (matchIndex - lastMatchIndex);\n    }\n\n    return weight;\n  }\n\n  function countSections(name) {\n    let count = 0;\n\n    const l = name.length;\n\n    for (let i = 0; i < l; i++) {\n      if (indexIsSectionStart(name, i)) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  class Item {\n    constructor(name, index) {\n      this.name = name;\n      this.mainIndex = index;\n    }\n\n    calcMatch(string) {\n      let matchIndexArr = [];\n      let searchIndex = -1;\n      let lookUpper = true;\n      let weight = 0;\n      let substringSize = 1;\n\n      const l = string.length;\n      const lowerTestName = this.name.toLowerCase();\n\n      for (let i = 0; i < l; i++) {\n        const currentChar = string.charAt(i);\n\n        if (searchIndex >= this.name.length) return false;\n\n        if (lookUpper) {\n          for (let j = searchIndex + 1; j < this.name.length; j++) {\n            if (currentChar === this.name[j].toLowerCase() && indexIsSectionStart(this.name, j)) {\n              searchIndex = j;\n              break;\n            }\n\n            searchIndex = -1;\n          }\n        } else {\n          searchIndex = lowerTestName.indexOf(currentChar, searchIndex + 1);\n        }\n\n        if (searchIndex > -1) {\n          if (matchIndexArr[matchIndexArr.length - 1] === searchIndex - 1) {\n            substringSize++;\n          } else {\n            substringSize = 1;\n          }\n\n          matchIndexArr.push(searchIndex);\n          weight += calculateWeight(\n            this.name,\n            substringSize,\n            searchIndex,\n            matchIndexArr[matchIndexArr.length - 2]\n          );\n\n          continue;\n        }\n\n        if (!lookUpper) {\n          matchIndexArr = [];\n          break;\n        }\n\n        i -= 1;\n        searchIndex = matchIndexArr[matchIndexArr.length - 1] || -1;\n        lookUpper = !lookUpper;\n      }\n\n      if (!matchIndexArr.length) {\n        return false;\n      }\n\n      const sectionCount = countSections(this.name);\n\n      weight = weight - Math.round(matchIndexArr[0] * 1.2) - (sectionCount * l);\n\n      return weight > 0 ? weight : 0;\n    }\n  }\n\n  function sortByWeight(a, b) {\n    return b.weight - a.weight;\n  }\n\n  class Result extends Array {\n    constructor(items) {\n      super();\n\n      if (!items.length) {\n        return false;\n      }\n\n      this.meta = items.sort(sortByWeight);\n      super.push.apply(this, this.meta.map(resultItem => resultItem.item.name));\n    }\n  }\n\n  class ResultItem {\n    constructor(item, weight) {\n      this.item = item;\n      this.weight = weight;\n    }\n  }\n\n  function isArray(item) {\n    if (Array.isArray) return Array.isArray(item);\n    return /array/i.test(Object.prototype.toString.call(item));\n  }\n\n  class Fuzz extends Array {\n    constructor(collection, options) {\n      super();\n\n      if (!isArray(collection)) {\n        throw new Error('Argument to Fuzz should be an array');\n      }\n\n      this.push.apply(this, collection);\n      this.main = this._prepareCollection();\n      this.options = Object.assign({\n        disableCache: false,\n      }, options);\n      this.cache = new Cache();\n    }\n\n    parse(item) {\n      return item;\n    }\n\n    _prepareCollection() {\n      return this.map((item, i) => {\n        if (typeof item !== 'string') {\n          throw new Error('Argument to Fuzz should be an array of strings');\n        }\n\n        return new Item(this.parse(item), i);\n      });\n    }\n\n    match(string) {\n      const query = string.replace(/\\s+/g, '').toLowerCase();\n      const cached = !this.options.disableCache && this.cache.check(query);\n\n      let searchArray = this.main;\n\n      if (cached) {\n        searchArray = this.cache.arr;\n      } else {\n        this.cache.clean();\n      }\n\n      const resultArray = searchArray.reduce((arr, item) => {\n        const searchItem = cached ? item.item : item;\n\n        const weight = searchItem.calcMatch(query);\n\n        if (weight !== false) {\n          arr.push(new ResultItem(searchItem, weight));\n        }\n\n        return arr;\n      }, []);\n\n      this.cache.arr = resultArray;\n      this.cache.query = query;\n\n      return new Result(resultArray);\n    }\n\n    simpleMatch(string) {\n      const queryRegex = new RegExp(string.split('').join('.*?'), 'i');\n      return this.filter(item => {\n        return queryRegex.test(item);\n      });\n    }\n\n    static match(string, collection) {\n      return (new Fuzz(collection)).match(string);\n    }\n  }\n\n  var fuzz = Fuzz;\n\n  return fuzz;\n\n}));\n","function isUpper(char) {\n  return char.toUpperCase() === char;\n}\n\nfunction nonWordChar(char) {\n  return /\\W/.test(char);\n}\n\nfunction indexIsSectionStart(string, index) {\n  return index === 0 ||\n    (index === 1 && isUpper(string[index])) ||\n    isUpper(string[index]) || nonWordChar(string[index - 1]);\n}\n\nfunction calculateWeight(name, substringSize, matchIndex, lastMatchIndex) {\n  const isSectionStart = indexIsSectionStart(name, matchIndex);\n\n  let weight = 0;\n\n  if (isSectionStart) {\n    weight += 85;\n  }\n\n  if (substringSize > 1) {\n    weight += (50 + (14 * (substringSize - 1)));\n  }\n\n  if (lastMatchIndex >= 0 && matchIndex - lastMatchIndex > 0) {\n    weight -= (matchIndex - lastMatchIndex);\n  }\n\n  return weight;\n}\n\nfunction countSections(name) {\n  let count = 0;\n\n  const l = name.length;\n\n  for (let i = 0; i < l; i++) {\n    if (indexIsSectionStart(name, i)) {\n      count++;\n    }\n  }\n\n  return count;\n}\n\nclass Item {\n  constructor(name, index) {\n    this.name = name;\n    this.mainIndex = index;\n  }\n\n  calcMatch(string) {\n    let matchIndexArr = [];\n    let searchIndex = -1;\n    let lookUpper = true;\n    let weight = 0;\n    let substringSize = 1;\n\n    const l = string.length;\n    const lowerTestName = this.name.toLowerCase();\n\n    for (let i = 0; i < l; i++) {\n      const currentChar = string.charAt(i);\n\n      if (searchIndex >= this.name.length) return false;\n\n      if (lookUpper) {\n        for (let j = searchIndex + 1; j < this.name.length; j++) {\n          if (currentChar === this.name[j].toLowerCase() && indexIsSectionStart(this.name, j)) {\n            searchIndex = j;\n            break;\n          }\n\n          searchIndex = -1;\n        }\n      } else {\n        searchIndex = lowerTestName.indexOf(currentChar, searchIndex + 1);\n      }\n\n      if (searchIndex > -1) {\n        if (matchIndexArr[matchIndexArr.length - 1] === searchIndex - 1) {\n          substringSize++;\n        } else {\n          substringSize = 1;\n        }\n\n        matchIndexArr.push(searchIndex);\n        weight += calculateWeight(\n          this.name,\n          substringSize,\n          searchIndex,\n          matchIndexArr[matchIndexArr.length - 2]\n        );\n\n        continue;\n      }\n\n      if (!lookUpper) {\n        matchIndexArr = [];\n        break;\n      }\n\n      i -= 1;\n      searchIndex = matchIndexArr[matchIndexArr.length - 1] || -1;\n      lookUpper = !lookUpper;\n    }\n\n    if (!matchIndexArr.length) {\n      return false;\n    }\n\n    const sectionCount = countSections(this.name);\n\n    weight = weight - Math.round(matchIndexArr[0] * 1.2) - (sectionCount * l);\n\n    return weight > 0 ? weight : 0;\n  }\n}\n\nexport default Item;\n","function sortByWeight(a, b) {\n  return b.weight - a.weight;\n}\n\nexport default class Result extends Array {\n  constructor(items) {\n    super();\n\n    if (!items.length) {\n      return false;\n    }\n\n    this.meta = items.sort(sortByWeight);\n    super.push.apply(this, this.meta.map(resultItem => resultItem.item.name));\n  }\n}\n","import Cache from './cache';\nimport Item from './item';\nimport Result from './result';\nimport ResultItem from './result-item';\n\nfunction isArray(item) {\n  if (Array.isArray) return Array.isArray(item);\n  return /array/i.test(Object.prototype.toString.call(item));\n}\n\nclass Fuzz extends Array {\n  constructor(collection, options) {\n    super();\n\n    if (!isArray(collection)) {\n      throw new Error('Argument to Fuzz should be an array');\n    }\n\n    this.push.apply(this, collection);\n    this.main = this._prepareCollection();\n    this.options = Object.assign({\n      disableCache: false,\n    }, options);\n    this.cache = new Cache();\n  }\n\n  parse(item) {\n    return item;\n  }\n\n  _prepareCollection() {\n    return this.map((item, i) => {\n      if (typeof item !== 'string') {\n        throw new Error('Argument to Fuzz should be an array of strings');\n      }\n\n      return new Item(this.parse(item), i);\n    });\n  }\n\n  match(string) {\n    const query = string.replace(/\\s+/g, '').toLowerCase();\n    const cached = !this.options.disableCache && this.cache.check(query);\n\n    let searchArray = this.main;\n\n    if (cached) {\n      searchArray = this.cache.arr;\n    } else {\n      this.cache.clean();\n    }\n\n    const resultArray = searchArray.reduce((arr, item) => {\n      const searchItem = cached ? item.item : item;\n\n      const weight = searchItem.calcMatch(query);\n\n      if (weight !== false) {\n        arr.push(new ResultItem(searchItem, weight));\n      }\n\n      return arr;\n    }, []);\n\n    this.cache.arr = resultArray;\n    this.cache.query = query;\n\n    return new Result(resultArray);\n  }\n\n  simpleMatch(string) {\n    const queryRegex = new RegExp(string.split('').join('.*?'), 'i');\n    return this.filter(item => {\n      return queryRegex.test(item);\n    });\n  }\n\n  static match(string, collection) {\n    return (new Fuzz(collection)).match(string);\n  }\n}\n\nexport default Fuzz;\n","export default class Cache {\n  construct() {\n    this.arr = null;\n    this.query = null;\n  }\n\n  clean() {\n    this.arr = null;\n    this.query = null;\n  }\n\n  check(query) {\n    if (!this.query || !query) {\n      return false;\n    }\n\n    if (query.length < this.query.length) {\n      return false;\n    }\n\n    if (query === this.query) {\n      return true;\n    }\n\n    if (query.indexOf(this.query) === 0) {\n      return true;\n    }\n\n    return false;\n  }\n}\n","export default class ResultItem {\n  constructor(item, weight) {\n    this.item = item;\n    this.weight = weight;\n  }\n}\n"],"sourceRoot":"/source/"}